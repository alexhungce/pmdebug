/*
 * Copyright (C) 2011 Canonical
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
global tasks_frozen
global tasks_thawed
global tasks_frozen_names

global funcs_entered
global funcs_returned

global saved_device_name
global saved_device_driver_name

global devices_suspended
global devices_resumed

global reboot_funcname
global ledflash_funcname
global beep_funcname
global parent_pid
global minimodem
global baud

global pages_copied
global free_swap
global saved_nr_pages
global saved_flags




/*
 *  TODO:  check time we spent in suspend, to see if we don't get S4 bouncing
 */

%{
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/rtc.h>
#include <linux/timex.h>
#include <linux/pm.h>
#include <linux/swap.h>
#include <linux/lzo.h>
#include <asm/siginfo.h>
#include <asm/rtc.h>
#include <asm/io.h>

#define RTC_HASH_MAX 16127999

#define PAGES_FOR_IO		((4096 * 1024) >> PAGE_SHIFT)
#define SF_NOCOMPRESS_MODE	2
#define LZO_HEADER		sizeof(size_t)
#define LZO_UNC_SIZE		(LZO_UNC_PAGES * PAGE_SIZE)
#define LZO_UNC_PAGES		32
#define LZO_CMP_PAGES		DIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \
                                     LZO_HEADER, PAGE_SIZE)

%}

%( kernel_v < "3.2.0" %?
%{
/* for minimodem */
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/delay.h>
#include <asm/io.h>
#if defined(CONFIG_MIPS) || defined(CONFIG_X86)
/* Use the global PIT lock ! */
# include <asm/i8253.h>
#else
# include <asm/8253pit.h>
static DEFINE_RAW_SPINLOCK(i8253_lock);
#endif
%}
%:
%{
#if defined(CONFIG_MIPS) || defined(CONFIG_X86)
/* Use the global PIT lock ! */
# include <linux/i8253.h>
#endif
%}
%)

%{
/* Bell 101 (110 baud) binary AFSK frequencies */
#define BELL101_BFSK_BAUD		110
#define	BELL101_BFSK_MARK		1270
#define BELL101_BFSK_SPACE		1070

/* Bell 103 (300 baud) binary AFSK frequencies */
#define BELL103_BFSK_BAUD		300
#define	BELL103_BFSK_MARK		1270
#define BELL103_BFSK_SPACE		1070

/* Bell ??? (600 baud) binary AFSK frequencies */
#define BELLxxx_BFSK_BAUD		600
#define	BELLxxx_BFSK_MARK		1270
#define BELLxxx_BFSK_SPACE		1070

/* Bell 202 (1200 baud) binary AFSK frequencies */
#define BELL202_BFSK_BAUD		1200
#define	BELL202_BFSK_MARK		1200
#define BELL202_BFSK_SPACE		2200

#define PCSP_MODEM_DEFAULT_BFSK_STOPBITSX10	10


/* Defaults */
static int bfsk_baud		= BELL101_BFSK_BAUD;
static int bfsk_mark		= BELL101_BFSK_MARK;
static int bfsk_space		= BELL101_BFSK_SPACE;
static int bfsk_stopbitsX10	= PCSP_MODEM_DEFAULT_BFSK_STOPBITSX10;

void pcspkr_baud(unsigned long baud)
{
	switch (baud) {
	case 1200:
		bfsk_baud = BELL202_BFSK_BAUD;
		bfsk_mark = BELL202_BFSK_MARK;
		bfsk_space = BELL202_BFSK_SPACE;
		break;
	case 600:
		bfsk_baud = BELLxxx_BFSK_BAUD;
		bfsk_mark = BELLxxx_BFSK_MARK;
		bfsk_space = BELLxxx_BFSK_SPACE;
		break;
	case 300:
		bfsk_baud = BELL103_BFSK_BAUD;
		bfsk_mark = BELL103_BFSK_MARK;
		bfsk_space = BELL103_BFSK_SPACE;
		break;
	case 110:
	default:
		bfsk_baud = BELL101_BFSK_BAUD;
		bfsk_mark = BELL101_BFSK_MARK;
		bfsk_space = BELL101_BFSK_SPACE;
		break;
	}
}

/*
 *  The following pcspkr_ functions were derived from
 *  a driver from Kamal Mostafa which works with his
 *  minimodem project (http://www.whence.com/minimodem
 */
void pcspkr_tone(unsigned long frequency)
{
	static unsigned int pcspkr_current_frequency;
	unsigned char val;

	if (frequency != pcspkr_current_frequency) {
		if (pcspkr_current_frequency == 0)
                	outb_p(0xb6, 0x43); /* Ctr 2, squarewave, binary */

		if (frequency > 20 && frequency < 32767) {
			unsigned int count = (PIT_TICK_RATE + frequency/2) / frequency;
			/* write count to select desired tone frequency */
			outb_p(count & 0xff, 0x42);
			outb_p((count >> 8) & 0xff, 0x42);
			val = inb_p(0x61) | 0x03;	/* on */
		} else
			val = inb_p(0x61) & 0xfc;	/* off */

		outb_p(val, 0x61);
		pcspkr_current_frequency = frequency;
	}
}

void pcspkr_delay_nsec(unsigned long duration_nsec)
{
	if (duration_nsec > 1000) {
		unsigned long duration_usec = duration_nsec / 1000;
		if (duration_usec > 1000) {
			unsigned long duration_msec = duration_usec / 1000;
			if (duration_msec) {
				mdelay(duration_msec);
				duration_usec -= duration_msec * 1000;
				duration_nsec -= duration_msec * 1000000;
			}
		}
		if (duration_usec) {
			udelay(duration_usec);
			duration_nsec -= duration_usec * 1000;
		}
	}
	if (duration_nsec)
		ndelay(duration_nsec);
}

void pcspkr_tone_nsec(unsigned long frequency, unsigned long duration_nsec)
{
    	pcspkr_tone(frequency);
    	pcspkr_delay_nsec(duration_nsec);
}

void pcspkr_generate_bfsk(const char *str)
{
	unsigned long flags;
	unsigned long nsec = (1000000000 + bfsk_baud/2) / bfsk_baud;

	pcspkr_tone_nsec(bfsk_mark, 500*1000*1000);	/* 500ms leader tone */

	raw_spin_lock_irqsave(&i8253_lock, flags);
	while (*str) {
		int i;
		unsigned char c = *str++;


		/*
        	 * generate 8-bit ASCII framing pattern:
		 *	1.0 start bit (bfsk_space)
		 *	8.0 data bits (1==bfsk_mark, lsb first)
		 *	m.n stop bits (bfsk_mark)
		 */
		pcspkr_tone_nsec(bfsk_space, nsec);
		for (i=0; i<8; i++)
			pcspkr_tone_nsec((c & (1<<i)) ? bfsk_mark : bfsk_space, nsec);
		pcspkr_tone_nsec(bfsk_mark, bfsk_stopbitsX10 * nsec / 10);

		mdelay(1);
    	}
	raw_spin_unlock_irqrestore(&i8253_lock, flags);
	pcspkr_tone(0);
}

%}

function set_baud(baud: long) %{
	pcspkr_baud(THIS->baud);
%}

function handle_args() {
	parent_pid = strtol(@1, 10)
	reboot_funcname = @2
	ledflash_funcname = @3
	beep_funcname = @4
	minimodem = strtol(@5, 10)
	baud = strtol(@6, 10)

	set_baud(baud)
}

function signal_proc:long(this_pid: long)
%{
	pid_t this_pid = (pid_t)THIS->this_pid;
	struct pid *pid = find_vpid(this_pid);
	if (pid) {
		kill_pid(pid, SIGUSR1, 1);
		THIS->__retvalue = 0;
	} else
		THIS->__retvalue = -1;
%}

/*
 *  Flash keyboard LEDs
 */
function led_flash() %{
#define I8042_DATA_REG          0x60
#define I8042_STATUS_REG        0x64

	int i;
	int val = 0;

	for (i=0;i<10;i++) {
		val ^= 7;

		while (inb(I8042_STATUS_REG) & 0x2)
			;

		outb(0x00, 0x80);
		outb(0xed, I8042_DATA_REG);
		while (inb(I8042_STATUS_REG) & 0x2)
			;
		outb(0x00, 0x80);
		outb(val, I8042_DATA_REG);

		mdelay(200);
	}
%}

/*
 *  Beep at freq Hz.
 */
function beep(freq: long, delay: long) %{
        pcspkr_tone_nsec(THIS->freq, THIS->delay * 1000000);
%}

/*
 *  Dirty reboot via ICH
 */
function ich_reboot() %{
	outb(0x2, 0xcf9);
	outb(0x00, 0x80);
	outb(0x4, 0xcf9);
	outb(0x00, 0x80);
	outb(0xe, 0xcf9);
%}

function device_name:string (dev: long) %{
	struct device *dev = (struct device*)(long)THIS->dev;

	strlcpy(THIS->__retvalue, dev_name(dev), MAXSTRINGLEN);
%}

function device_driver_name:string (dev: long) %{
	struct device *dev = (struct device*)(long)THIS->dev;

	strlcpy(THIS->__retvalue, dev_driver_string(dev), MAXSTRINGLEN);
%}

function bfsk_write(msg: string) %{
	char *str = (char*)THIS->msg;
	pcspkr_generate_bfsk(str);
%}

function console_write(msg: string) %{
	char *str = (char*)THIS->msg;

	printk("%s", THIS->msg);
%}

function WriteTrace(msg: string) {
	if (minimodem & 1)
		bfsk_write(msg)
	printf("PM-TRACE: %s", msg)
	console_write(msg)
}

function WriteInfo(msg: string) {
	if (minimodem)
		bfsk_write(msg)
	printf("PM-INFO: %s", msg)
	console_write(msg)
}

function WriteTest(msg: string) {
	if (minimodem & 8)
		bfsk_write(msg)
	printf("\nPM-TEST: %s\n", msg)
	console_write(msg)
}

function WriteDebug(msg: string) {
	if (minimodem)
		bfsk_write(msg)
	printf("PM-DEBUG: %s", msg)
	console_write(msg)
}

function WriteTaskDebug(msg: string) {
	if (minimodem & 4)
		bfsk_write(msg)
	printf("PM-TASK-DEBUG: %s", msg)
	console_write(msg)
}

function WriteDeviceDebug(msg: string) {
	if (minimodem & 2)
		bfsk_write(msg)
	printf("PM-DEV-DEBUG: %s", msg)
	console_write(msg)
}

function rtc_save_restore(save: long) %{

        static struct rtc_time time;

	if ((long)THIS->save)
		get_rtc_time(&time);
	else
        	set_rtc_time(&time);
%}

function hash_symbol:long(symbol: string) %{
	const char *s;
	const char *str = (char*)THIS->symbol;
	unsigned long g,h = 0;

	for (s = str; *s; s++) {
		h = (h<<4) + *s;
		g = h & 0xf0000000;
		if (g) {
			h ^= (g>>24);
			h ^= g;
		}
	}

	h %= RTC_HASH_MAX;

	THIS->__retvalue = h;
%}

function hash_dev_func:long(dev: long, suspend: long) %{
	struct device *dev = (struct device *)(long)THIS->dev;
	unsigned long suspend = THIS->suspend;
	unsigned long addr = 0;

	if (suspend) {
		if (dev->class) {
			if (dev->class->pm)
				addr = (unsigned long)dev->class->pm->suspend;
			else
				addr = (unsigned long)dev->class->suspend;
		}

		if (dev->type)
			if (dev->type->pm)
				addr = (unsigned long)dev->type->pm->suspend;

		if (dev->bus) {
			if (dev->bus->pm)
				addr = (unsigned long)dev->bus->pm->suspend;
			else
				addr = (unsigned long)dev->bus->suspend;
		}
	} else {
		if (dev->class) {
			if (dev->class->pm)
				addr = (unsigned long)dev->class->pm->resume;
			else
				addr = (unsigned long)dev->class->resume;
		}

		if (dev->type)
			if (dev->type->pm)
				addr = (unsigned long)dev->type->pm->resume;

		if (dev->bus) {
			if (dev->bus->pm)
				addr = (unsigned long)dev->bus->pm->resume;
			else
				addr = (unsigned long)dev->bus->resume;
		}
	}

	addr %= RTC_HASH_MAX;

	THIS->__retvalue = addr;
%}

function store_hash_long(h: long) %{
	unsigned long h = (unsigned long)THIS->h;

        static struct rtc_time time = {
                .tm_sec = 0,
                .tm_min = 0,
                .tm_hour = 0,
                .tm_mday = 7,
                .tm_mon = 5,
                .tm_year = 106,
                .tm_wday = 3,
                .tm_yday = 160,
                .tm_isdst = 1
        };

	h %= RTC_HASH_MAX;

        time.tm_year = (h % 100);
        h /= 100;
        time.tm_mon = (h % 12);
        h /= 12;
        time.tm_mday = (h % 28) + 1;
        h /= 28;
        time.tm_hour = (h % 24);
        h /= 24;
        time.tm_min = (h % 20) * 3;
        h /= 20;

        set_rtc_time(&time);
%}

/*
function pm_noirq_op_func:long(op: long, state: long) %{
	const struct dev_pm_ops * = (const struct dev_pm_ops *)THIS->op;
	pm_message_t state = (pm_message_t)THIS->state;

	if (op == NULL) {
		THIS->__retvalue = 0;
		return
	} else {
		switch (state.event) {
		case PM_EVENT_FREEZE:
		case PM_EVENT_QUIESCE:
			THIS->__retvalue = (unsigned long)ops->freeze_noirq;
			break;
		case PM_EVENT_HIBERNATE:
			THIS->__retvalue = (unsigned long)ops->poweroff_noirq;
			break;
		case PM_EVENT_THAW:
		case PM_EVENT_RECOVER:
			THIS->__retvalue = (unsigned long)ops->thaw_noirq;
			break;
		case PM_EVENT_RESTORE:
			THIS->__retvalue = (unsigned long)ops->restore_noirq;
			break;
		default:
			THIS->__retvalue = 0;
		}
	}
%}
*/

/*
function pm_noirq_op_ops:long(dev: long) %{
	struct device *dev = (struct device *)THIS->dev;
	const struct dev_pm_ops *ops;
	unsigned long suspend = THIS->suspend;
	unsigned long addr = 0;

	if (dev->pwr_domain)
		ops = &dev->pwr_domain->ops;
	else if (dev->type && dev->type->pm)
		ops = dev->type->pm;
	else if (dev->class && dev->class->pm)
		ops = dev->class->pm;
	else if (dev->bus && dev->bus->pm)
		ops = dev->bus->pm;
	else
		ops = NULL;

	THIS->__retvalue = (unsigned long)ops;
%}
*/

probe kernel.function("__device_suspend@drivers/base/power/main.c") {
	/* We are going to call pm_op() on the device which calls the relevant suspend
	   callback so hash this function to catch it if it locks up */
	h = hash_dev_func($dev, 1)
	store_hash_long(h)
}

probe kernel.function("__thaw_process@kernel/freezer.c") {
	s = sprintf("thaw task %d \"%s\"\n",
		$p->pid, kernel_string($p->comm))
	WriteTaskDebug(s)
	tasks_thawed[$p->pid] = 1
}

probe begin {
	handle_args()

	rtc_save_restore(1)
	WriteInfo("Ready to run S4 test\n")

	if (parent_pid != 0)
		signal_proc(parent_pid)
}

probe end {
	rtc_save_restore(0)

	frozen_count = 0
	foreach (task in tasks_frozen)
		frozen_count++

	thawed_count = 0
	foreach (task in tasks_thawed)
		thawed_count++

	foreach (func in funcs_entered)
		entered_count++

	foreach (func in funcs_returned)
		returned_count++

	s = sprintf("%d functions entered, %d functions returned.\n",
		entered_count, returned_count)
	WriteInfo(s)

	s = sprintf("%d tasks frozen and %d tasks thawed.\n", frozen_count, thawed_count)
	WriteInfo(s)

	foreach (frozen in tasks_frozen)
		if (!([frozen] in tasks_thawed)) {
			s = sprintf("Task pid:%d '%s' was frozen but NOT thawed.\n",
				frozen, tasks_frozen_names[frozen])
			WriteTest(s)
	}
	WriteInfo("S4 test completed.\n")
}

function trace_in(str: string)
{
	f = probefunc()
	h = hash_symbol(f)
	store_hash_long(h)

	if (f == reboot_funcname)
		ich_reboot()
	if (f == ledflash_funcname)
		led_flash()
	if (f == beep_funcname) {
		beep(880,200)
		beep(440,200)
		beep(0,0)
	}

	funcs_entered[f] = 1
	if (str == "")
		s = sprintf("-> %s()\n", f)
	else
		s = sprintf("-> %s() %s\n", f, str)
	WriteTrace(s)
}

function trace_out(ret: string)
{
	f = probefunc()

	if (f == reboot_funcname)
		ich_reboot()
	if (f == ledflash_funcname)
		led_flash()
	if (f == beep_funcname) {
		beep(440,200)
		beep(880,200)
		beep(0,0)
	}
	funcs_returned[f] = 1
	if (ret == "")
		s = sprintf("<- %s()\n", f)
	else
		s = sprintf("<- %s() [%s]\n", f, ret)
	WriteTrace(s)
}

/* Bad places to be tracing: */
probe kernel.function("panic@kernel/panic.c"),
      kernel.function("oops_enter@kernel/panic.c"),
      kernel.function("__stack_chk_fail@kernel/panic.c")
{
	trace_in("")
}

/*
 *
 * S4 hibernate path is as follows:
 *
 * state_store()
 *	buffer = "disk"
 *	hibernate()
 *		pm_prepare_console()
 *		usermodehelper_disable()
 *		create_basic_memory_bitmaps()
 *			memory_bm_create(bm1,..)
 *				create_mem_extents()
 *					kzalloc() --> ENOMEM
 *				create_bm_block_list()
 *				get_image_page() --> NULL --> NO MEM
 *			memory_bm_create(bm2,..)
 *				create_mem_extents()
 *					kzalloc() --> ENOMEM
 *				create_bm_block_list()
 *				get_image_page() --> NULL --> NO MEM
 *			mark_nosave_pages()
 *
 *		sys_sync()
 *			if we got here, we are doing well
 *		prepare_processes()
 *			freeze_processes() --> -EBUSY
 *				try_to_freeze_tasks(true) --> -EBUSY
 *				try_to_freeze_tasks(false) --> -EBUSY
 *				oom_killer_disable() [ inlines, won't fail ]
 *
 *		hibernation_snapshot()
 *			platform_begin() --> ?
 *				hibernation_ops->begin()
 *					acpi_hibernation_begin() --> -ENOMEM
 *						suspend_nvs_alloc() --> -ENOMEM
 *				or	acpi_hibernation_begin_old()
 *						acpi_sleep_prepare() --> -EFAULT
 *							acpi_set_firmware_waking_vector() [ never fails ]
 *							acpi_enable_wakeup_devices() [ never fails ]
 *							acpi_enter_sleep_state_prep() [ TODO, returns error, not checked! ]
 *						suspend_nvs_alloc() --> -ENOMEM
 *			dpm_prepare() --> -EBUSY
 *			hibernate_preallocate_memory() --> ?
 *				do_gettimeofday() --> [ won't fail ]
 *				memory_bm_create() --> ENOMEM
 *					create_mem_extents()
 *						kzalloc() --> ENOMEM
 *					create_bm_block_list()
 *					get_image_page() --> NULL --> NO MEM
 *				memory_bm_create() --> ENOMEM
 *					create_mem_extents()
 *						kzalloc() --> ENOMEM
 *					create_bm_block_list()
 *					get_image_page() --> NULL --> NO MEM
 *				count_highmem_pages() --> save_highmem
 *				count_data_pages() --> saveable
 *				minimum_image_size()--> pages
 *				shrink_all_memory() --> [ no ret ]
 *				preallocate_image_highmem() --> pages_highmem
 *					preallocate_image_pages() --> num pages
 *				preallocate_image_memory() --> pages
 *					preallocate_image_pages() --> num pages
 *				if ()
 *					preallocate_image_highmem() --> pages_highmem
 *						preallocate_image_pages() --> num pages
 *					preallocate_image_highmem() --> pages
 *						preallocate_image_pages() --> num pages
 *				else
 *					preallocate_highmem_fraction() --> size
 *						preallocate_image_pages() --> num pages
 *					preallocate_image_memory() --> pages_huighmem
 *						preallocate_image_pages() --> num pages
 *				free_unnecessary_pages --> [ no ret ]
 *				do_gettimeofday() --> [ won't fail ]
 *				swsusp_show_speed() [ no ret ]
 *
 *			suspend_console() [ no ret ]
 *			pm_restrict_gfp_mask [ no ret ]
 *			dpm_suspend() --> ??
 *				device_suspend() --> ??
 *					async_schedule()
 *						async_syspend()
 *					__device_suspend() --> EBUSY
 *						pm_op()
 *						legacy_suspend()
 *				[TODO tidy up what funcs we need ]
 *			create_image() --> ?
 *				dpm_suspend_noirq() --> ??
 *					device_suspend_noirq() --> ??
 *						pm_noirq_op() --> INVAL,
 *							ops->suspend_noirq()
 *
 *				platform_pre_snapshot() --> ??
 *					hibernation_ops->pre_snapshot()
 *						acpi_pm_prepare() --> ??
 *							__acpi_pm_prepare() --> ??
 *								acpi_sleep_prepare() --> EFAULT (null acpi_wakeup_address)
 *									acpi_set_firmware_waking_vector()
 *									acpi_enable_wakeup_devices()
 *									acpi_enter_sleep_state_prep()
 *							acpi_pm_pre_suspend() --> ??
 *								acpi_pm_freeze() [ no ret ]
 *								suspend_nvs_save --> ENOMEM
 *
 *					or	acpi_pm_pre_suspend()
 *							acpi_pm_freeze() [ no ret ]
 *							suspend_nvs_save --> ENOMEM
 *
 *				disable_nonboot_cpus() --> ?? (not yet figured out what the error is)
 *				local_irq_disable() [ no ret ]
 *				syscore_suspend() --> ??
 *					ops->suspend() [ TODO - more debug on this ]
 *				save_processor_state() [ no ret ]
 *				swsusp_arch_suspend() --> ENOMEM (can't tap this, it's assembler)
 *					swsusp_save() --> ENOMEM
 *						drain_local_pages() [ no ret ]
 *							drain_pages()
 *								per_cpu_ptr()
 *								free_pcppages_bulk()
 *						count_data_pages() -> nr_pages
 *						count_highmem_pages() -> nr_highmem
 *						enough_free_mem() --> 1 = yes, 0 return ENOMEM
 *						swsusp_alloc() --> 1 = return ENOMEM
 *							alloc_highmem_pages()
 *							alloc_image_page() --> NULL --> ENOMEM
 *							memory_bm_set_bit()
 *							swsusp_free() on failure to free pages
 *						drain_local_pages() [ no ret ]
 *						copy_data_pages() [ no ret ]
 *
 *				magic ... resume back here
 *				restore_processor_state() [ no ret ]
 *				platform_leave() [ no ret ]
 *				syscore_resume() [ no ret ]
 *				local_irq_enable() [ no ret ]
 *				enable_nonboot_cpus) [ no ret ]
 *				platform_finish() [ no ret ]
 *				dpm_resume_noirq() [ no ret ]
 *
 * resume_devices:
 *			dpm_resume() --> [ no ret ]
 *			pm_restore_gfp_mask() [ no ret ]
 *			resume_console() [ no ret ]
 *			dpm_complete() [ no ret ]
 *			return [ error ]
 * recover_platform:
 *			platform_recover() [ no ret ]
 *			goto resume_devices:
 *
 *	hibernate() [..continued ]
 *		...
 *		in suspend path {
 *			swsusp_write()
 *				snapshot_get_image_size() --> pages
 *				get_swap_writer() --> ??
 *					swsusp_swap_check() --> ??
 *						swap_type_of() --> ENODEV
 *						blkdev_get() --> ??
 *						set_blocksize() --> EINVAL
 *				enough_swap() --> ??
 *				snapshot_read_next()  --> ??
 *				swap_write_page() --> (write header)
 *				save_image()  --> ??
 *			    or 	save_image_lzo() --> ??
 *				swap_writer_finish --> ??
 *			swsusp_free()
 *			power_down()
 *			pm_restore_gfp_mask()
 *		}
 *		Thaw:
 *		thaw_processes()
 *		free_basic_memory_bitmaps()
 *		usermodehelper_enable()
 *		pm_notifier_call_chain()
 *		pm_restore_console()
 *
 *
 *
 */

/* We kick off with state_store() */
probe kernel.function("state_store@kernel/power/main.c") {
	trace_in("")

	s = sprintf("/sys/power/state = \"%s\"\n", kernel_string($buf))
	WriteDebug(s)

	if (kernel_string($buf) != "disk") {
		s = sprintf("state_store(): /sys/power/state did not get 'disk' string to initiate hibernate, got %s instead.\n", kernel_string($buf))
		WriteTest(s)
	}
}

probe kernel.function("state_store@kernel/power/main.c").return {
	trace_out($$return)
	if ($return != 4) {
		s = sprintf("state_store(): Expecting a return value of 4, got %d instead.\n", $return)
		WriteTest(s)
	}
	exit()
}

/* Trace pm_notifier_call_chain as it can cause hibernate() to fail */
probe kernel.function("pm_notifier_call_chain@kernel/power/main.c") {
	trace_in("")
}

probe kernel.function("pm_notifier_call_chain@kernel/power/main.c").return {
	trace_out($$return)

	if (errno_str($return) == "EINVAL")
		WriteTest("pm_notifier_call_chain() failed on a bad notifier call chain.\n")
}

/* Trace usermodhelper_disable as it can cause hibernate() to fail */
probe kernel.function("usermodehelper_disable@kernel/kmod.c") {
	trace_in("")
}

probe kernel.function("usermodehelper_disable@kernel/kmod.c").return {
	trace_out($$return)

	if (errno_str($return) == "EAGAIN")
		WriteTest("usermodehelper_disable() running helpers did not reduce to zero in 5 seconds.\n")
}


/* Trace create_basic_memory_bitmaps as it can cause hibernate to fail */
probe kernel.function("create_basic_memory_bitmaps@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("create_basic_memory_bitmaps@kernel/power/snapshot.c").return {
	trace_out($$return)

	if (errno_str($return) == "ENOMEM")
		WriteTest("create_basic_memory_bitmaps() failed to create bitmaps needed for marking page\nframes that should not be saved and for free page frames, out of memory!\n")
}

/* Trace memory_bm_create as it can cause create_basic_memory_bitmaps to fail */
probe kernel.function("memory_bm_create@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("memory_bm_create@kernel/power/snapshot.c").return {
	trace_out($$return)

	if (errno_str($return) == "ENOMEM")
		WriteTest("memory_bm_create() failed to create bitmaps, out of memory!\n")
}

/* Trace create_mem_extents() as it can cause memory_bm_create to fail */
probe kernel.function("create_mem_extents@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("create_mem_extents@kernel/power/snapshot.c").return {
	trace_out($$return)

	if (errno_str($return) == "ENOMEM")
		WriteTest("create_mem_extents() failed to create a list of memory extents representing\ncontiguous ranges of PFNs. Out of memory!\n")
}

/* Trace create_bm_block_list() as it can cause memory_bm_create to fail */
probe kernel.function("create_bm_block_list@kernel/power/snapshot.c") {
	trace_in("")
}

/* function is inlined, so return cannot be tapped
probe kernel.function("create_bm_block_list@kernel/power/snapshot.c").return {
	if (errno_str($return) == "ENOMEM")
		Writetest("create_bm_block_list() failed to create a list of block bitmap objects. Out\nof memory!\n");
}
*/
/* Trace get_image_page() as it can cause memory_bm_create to fail */
probe kernel.function("get_image_page@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("get_image_page@kernel/power/snapshot.c").return {
	trace_out($$return)
	if ($return == 0)
		WriteTest("get_image_page() failed to get a zero'd page. Out\nof memory!\n");
}

/* Trace mark_nosave_pages() - it cannot fail */
probe kernel.function("mark_nosave_pages@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("mark_nosave_pages@kernel/power/snapshot.c").return {
	trace_out($$return)
}

/* Trace sys_sync() - if we get here we've done well */

probe kernel.function("sys_sync@fs/sync.c") {
	trace_in("")
}

probe kernel.function("sys_sync@fs/sync.c").return {
	trace_out($$return)
	WriteTest("sync() completed.\n");
}

probe kernel.function("prepare_processes@kernel/power/hibernate.c") {
	trace_in("")
}

/* inlined, so skip
probe kernel.function("prepare_processes@kernel/power/hibernate.c").return {
	if (errno_str($return) == "EBUSY")
		Writetest("prepare_processes() failed to freeze all the processes, returning -EBUSY and failing.\n")
}
*/

/* test freeze_processes() */
probe kernel.function("freeze_processes@kernel/power/process.c") {
	trace_in("")
}

probe kernel.function("freeze_processes@kernel/power/process.c").return {
	trace_out($$return)

	frozen_count = 0
	foreach (task in tasks_frozen)
		frozen_count++

	if (errno_str($return) == "EBUSY")
		WriteTest("freeze_processes(): could not freeze all the tasks.\n")
	else if ($return != 0)
		WriteTest("freeze_processes(): failed for some unknown reason.\n")
	else {
		s = sprintf("%d tasks frozen successfully.\n", frozen_count)
		WriteTest(s)
	}
}

probe kernel.function("try_to_freeze_tasks@kernel/power/process.c") {
	trace_in("")
}

probe kernel.function("try_to_freeze_tasks@kernel/power/process.c").return {
	trace_out($$return)
	if (errno_str($return) == "EBUSY") {
		if ($sig_only == 0)
			WriteTest("try_to_freeze_tasks(): could not freeze all the userspace tasks and was left with some unfreezable tasks.\n")
		else
			WriteTest("try_to_freeze_tasks(): could not freeze all the remaining non-userspace tasks\nand was left with some unfreezable tasks.\n")
	}
}

probe kernel.function("hibernation_snapshot@kernel/power/hibernate.c") {
	trace_in("")
}

probe kernel.function("hibernation_snapshot@kernel/power/hibernate.c").return {
	trace_out($$return)
}
/*
 *  ACPI hibernations_ops
 *      .begin = acpi_hibernation_begin,
 *      .end = acpi_pm_end,
 *      .pre_snapshot = acpi_pm_prepare,
 *      .finish = acpi_pm_finish,
 *      .prepare = acpi_pm_prepare,
 *      .enter = acpi_hibernation_enter,
 *      .leave = acpi_hibernation_leave,
 *      .pre_restore = acpi_pm_freeze,
 *      .restore_cleanup = acpi_pm_thaw,
 *
 *  ACPI acpi_hibernation_ops_old
 *      .begin = acpi_hibernation_begin_old,
 *      .end = acpi_pm_end,
 *      .pre_snapshot = acpi_pm_pre_suspend,
 *      .prepare = acpi_pm_freeze,
 *      .finish = acpi_pm_finish,
 *      .enter = acpi_hibernation_enter,
 *      .leave = acpi_hibernation_leave,
 *      .pre_restore = acpi_pm_freeze,
 *      .restore_cleanup = acpi_pm_thaw,
 *      .recover = acpi_pm_finish,
 *
 */
probe kernel.function("acpi_hibernation_begin@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_end@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_prepare@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_finish@drivers/acpi/sleep.c"),
      kernel.function("acpi_hibernation_enter@drivers/acpi/sleep.c"),
      kernel.function("acpi_hibernation_leave@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_freeze@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_thaw@drivers/acpi/sleep.c"),
      kernel.function("acpi_hibernation_begin_old@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_pre_suspend@drivers/acpi/sleep.c") {
	trace_in("")
}

probe kernel.function("acpi_pm_end@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_finish@drivers/acpi/sleep.c").return,
      kernel.function("acpi_hibernation_leave@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_freeze@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_thaw@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_pre_suspend@drivers/acpi/sleep.c").return {
	trace_out($$return)
}

probe kernel.function("acpi_hibernation_begin@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("acpi_hibernation_begin(): failed because suspend_nvs_alloc() could not allocate\nany NVS regions - usually because of a iomap failure.")
}

probe kernel.function("acpi_hibernation_begin@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("acpi_hibernation_begin(): failed because suspend_nvs_alloc() could not allocate\nany NVS regions - usually because of a iomap failure.")
}

probe kernel.function("acpi_hibernation_begin_old@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("acpi_hibernation_begin(): failed because suspend_nvs_alloc() could not allocate\nany NVS regions - usually because of a iomap failure.")
	else if (errno_str($return) == "EFAULT")
		WriteTest("acpi_hibernation_begin(): failed because acpi_wake_address has not been set.\n")
}

probe kernel.function("acpi_hibernation_begin_old@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("acpi_hibernation_begin_old(): failed because suspend_nvs_alloc() could not allocate\nany NVS regions - usually because of a iomap failure.")
	else if (errno_str($return) == "EFAULT")
		WriteTest("acpi_hibernation_begin_old(): failed because acpi_wake_address has not been set.\n")
}

probe kernel.function("acpi_pm_prepare@drivers/acpi/sleep.c").return {
	trace_out($$return)
	/* TODO __acpi_pm_prepare(), acpi_pm_pre_suspend, check return */
}

probe kernel.function("acpi_hibernation_enter@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "EFAULT")
		WriteTest("acpi_hibernation_enter(): failed because acpi_enter_sleep_state() returned, which it should not do.\n")
}

/*
 * Misc funcs used by acpi_sleep_prepare()
 */
probe kernel.function("acpi_set_firmware_waking_vector@drivers/acpi/acpica/hwsleep.c"),
      kernel.function("acpi_enable_wakeup_devices@drivers/acpi/wakeup.c"),
      kernel.function("acpi_enter_sleep_state_prep@drivers/acpi/acpica/hwsleep.c") {
	trace_in("")
}

probe kernel.function("acpi_set_firmware_waking_vector@drivers/acpi/acpica/hwsleep.c").return,
      kernel.function("acpi_enable_wakeup_devices@drivers/acpi/wakeup.c").return,
      kernel.function("acpi_enter_sleep_state_prep@drivers/acpi/acpica/hwsleep.c").return {
	trace_out($$return)
}

/* dpm functions */

probe kernel.function("dpm_prepare@drivers/base/power/main.c") {
	trace_in("")
}

probe kernel.function("dpm_prepare@drivers/base/power/main.c").return {
	trace_out($$return)
	if (errno_str($return) == "EBUSY")
		WriteTest("dpm_prepare(): a non-sysdev device could not transition state.\n")
}

probe kernel.function("hibernate_preallocate_memory@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("hibernate_preallocate_memory@kernel/power/snapshot.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("hibernate_preallocate_memory(): failed to allocate pre-allocate memory for\nhibernation image. It is necessary to create a copy of every page frame in use\nhowever there was not enough free memory to do this.\n");
}

/* Won't bother instrumenting these as they end up as inlined code
probe kernel.function("count_highmem_pages@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("count_highmem_pages@kernel/power/snapshot.c").return {
	trace_out($$return)
	s = sprintf("There are %d saveable highmem pages.\n", $$return)
	WriteInfo(s)
}

probe kernel.function("count_data_pages@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("count_data_pages@kernel/power/snapshot.c").return {
	trace_out($$return)
	s = sprintf("There are %d saveable non-highmem pages.\n", $$return)
	WriteInfo(s)
}

probe kernel.function("preallocate_image_pages@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("preallocate_image_pages@kernel/power/snapshot.c").return {
	trace_out($$return)
}

probe kernel.function("minimum_image_size@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("minimum_image_size@kernel/power/snapshot.c").return {
	trace_out($$return)
}
*/

probe kernel.function("shrink_all_memory@mm/vmscan.c") {
	trace_in("")
	s = sprintf("Requested to shrink %d pages.\n", $nr_to_reclaim)
	WriteInfo(s)
}

probe kernel.function("shrink_all_memory@mm/vmscan.c").return {
	trace_out($$return)
	s = sprintf("Was able to shrink %d pages.\n", $return)
	WriteInfo(s)
}

probe kernel.function("swsusp_show_speed@kernel/power/hibernate.c") {
	trace_in("")
	s = sprintf("%s %d pages.\n",
		kernel_string($msg), $nr_pages);
	WriteInfo(s)
}

probe kernel.function("swsusp_show_speed@kernel/power/hibernate.c").return {
	trace_out($$return)
}

probe kernel.function("dpm_suspend@drivers/base/power/main.c") {
	trace_in("")
	WriteInfo("Suspending all non-sysdev devices.\n");
}

probe kernel.function("dpm_suspend@drivers/base/power/main.c").return {
	trace_out($$return)

	if ($return != 0) {
		s = sprintf("dpm_suspend(): failed to suspend all devices.\n")
		WriteTest(s)
	}

	dev_ok = 0
	dev_fail = 0

	foreach (dev in devices_suspended)
		if (devices_suspended[dev] == 1)
			dev_ok++
		else
			dev_fail++

	if (dev_fail == 0)
		s = sprintf("%d devices suspended correctly.\n", dev_ok)
	else
		s = sprintf("%d of %d devices failed to suspend.\n", dev_fail, dev_ok)
	WriteTest(s)

	if (dev_fail > 0) {
		devs = ""
		foreach (dev in devices_suspended)
			if (devices_suspended[dev] == 0)
				devs = " " . dev

		s = sprintf("Devices that failed to suspend: %s.\n", devs)
		WriteInfo(s)
	}
}

probe kernel.function("create_image@kernel/power/hibernate.c") {
	trace_in("")
}

probe kernel.function("create_image@kernel/power/hibernate.c").return {
	trace_out($$return)
	if ($return != 0)
		WriteTest("create_image(): failed to create a hibernation image.\n");
}

probe kernel.function("platform_pre_snapshot@kernel/power/hibernate.c") {
	trace_in("")
}

/* is an inlined function, so cannot trace return
probe kernel.function("platform_pre_snapshot@kernel/power/hibernate.c").return {
	trace_out($$return)
}
*/

probe kernel.function("swsusp_save@kernel/power/snapshot.c") {
	trace_in("")
	WriteTest("Tasks frozen, now creating hibernation image.\n")
}

/* the following probe breaks S4 for some reason! */
/*
probe kernel.function("swsusp_save@kernel/power/snapshot.c").return {
	trace_in("")
	if (errno_str($return) == "ENOMEM")
		WriteTest("swsusp_save(): failed to create a hibernation image - ENOMEM.\n")
	else if ($return != 0) {
		s = sprintf("swsusp_save(): failed to create a hibernation image - %d\n", $return)
		WriteTest(s)
	} else
		WriteTest("swsusp_save(): hibernation image successfully created.\n")
}
*/

probe kernel.function("drain_local_pages@mm/page_alloc.c") {
	trace_in("")
}

probe kernel.function("drain_local_pages@mm/page_alloc.c").return {
	trace_out($$return)
}

probe kernel.function("enough_free_mem@kernel/power/snapshot.c") {
	trace_in("")
}

/* inlined, so no help
probe kernel.function("enough_free_mem@kernel/power/snapshot.c").return {
	trace_out($$return)
}
*/

probe kernel.function("swsusp_alloc@kernel/power/snapshot.c") {
	trace_in("")
}

/* inlined, so no help
probe kernel.function("swsusp_alloc@kernel/power/snapshot.c").return {
	trace_out($$return)
}
*/

probe kernel.function("copy_data_page@kernel/power/snapshot.c") {
	pages_copied++
}

probe kernel.function("copy_data_pages@kernel/power/snapshot.c") {
	trace_in("")
	WriteTest("Able to allocate enough pages, now copying image.\n");
}

/* this probe also breaks S4 for some reason!
probe kernel.function("copy_data_pages@kernel/power/snapshot.c").return {
	trace_out($$return)
	s = sprintf("Image copy completed, copied %d pages\n", pages_copied)
	WriteInfo(s)
}
*/

probe kernel.function("swsusp_write@kernel/power/swap.c") {
	trace_in("")
}

probe kernel.function("swsusp_write@kernel/power/swap.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOSPC")
		WriteTest("swsusp_write(): failed, no swap device or not enough free swap.\n")
	else if (errno_str($return) == "EFAULT")
		WriteTest("swsusp_write(): snapshot_read_next() most probably failed.\n")
	else if ($return < 0) {
		s = sprintf("swsusp_write(): failed for unknown reason: %d.\n", $return)
		WriteTest(s)
	} else
		WriteTest("Hibernation image and meta data written successfully.\n")
}

probe kernel.function("snapshot_get_image_size@kernel/power/snapshot.c") {
	trace_in("")
}

probe kernel.function("snapshot_get_image_size@kernel/power/snapshot.c").return {
	trace_out($$return)
	s = sprintf("Image size: %d pages.\n", $return)
	WriteInfo(s)
}

probe kernel.function("get_swap_writer@kernel/power/swap.c") {
	trace_in("")
}

probe kernel.function("get_swap_writer@kernel/power/swap.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM")
		WriteTest("get_swap_writer(): failed, cannot get zero'd page as a buffer.\n")
	else if (errno_str($return) == "ENOSPC")
		WriteTest("get_swap_writer(): failed, alloc_swapdev_block() failed.\n")
	else if ($return != 0)
		WriteTest("get_swap_writer(): failed, possibly swsusp_swap_check() failed.\n")
}

probe kernel.function("swsusp_swap_check@kernel/power/swap.c") {
	trace_in("")
	s = sprintf("Resume device: %s.\n", $swsusp_resume_device$$)
	WriteInfo(s)
}

/* inlined, so can't check returns
probe kernel.function("swsusp_swap_check@kernel/power/swap.c").return {
	trace_out($$return)
}
*/

probe kernel.function("swap_type_of@mm/swapfile.c") {
	trace_in("")
}

probe kernel.function("swap_type_of@mm/swapfile.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENODEV")
		WriteTest("swap_type_of(): failed, not a swap device? returned -ENODEV.\n")
	else if ($return < 0) {
		WriteTest("swap_type_of(): failed, returned for some unknown reason.\n")
	} else
		WriteTest("Looks like a correct swap device.\n")
}

probe kernel.function("blkdev_get@fs/block_dev.c") {
	trace_in("")
}

probe kernel.function("blkdev_get@fs/block_dev.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("blkdev_get(): failed to open the swap device, return: %d.\n", $return)
		WriteTest(s)
	}
	/* else WriteTest("Can open the swap device without any problems.\n") */
}

probe kernel.function("set_blocksize@fs/block_dev.c") {
	trace_in("")
}

probe kernel.function("set_blocksize@fs/block_dev.c").return {
	trace_out($$return)
	if (errno_str($return) == "EINVAL") {
		s = sprintf("set_blocksize(): failed, specified an incorrect block size of %d.\n", $size)
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("set_blocksize(): failed, unknown reason: %d.\n", $return)
		WriteTest(s)
	}
}

/*
lots of noise, disable this
probe kernel.funcion("swap_write_page@kernel/power/swap.c") {
	trace_in("")
}
*/

probe kernel.function("swap_write_page@kernel/power/swap.c").return {
	/* trace_out($$return) */
	if (errno_str($return) == "EINVAL")
		WriteTest("swap_write_page(): failed, handle->cur is not set.\n")
	else if (errno_str($return) == "ENOSPC")
		WriteTest("swap_write_page(): failed, no more free swap space.\n")
	else if ($return != 0) {
		s = sprintf("swap_write_page(): failed, unknown reason: %d.\n", $return)
		WriteTest(s)
	}
}

/*
lots of noise, disable this
probe kernel.function("snapshot_read_next@kernel/power/snapshot.c"){
}
*/

probe kernel.function("snapshot_read_next@kernel/power/snapshot.c").return {
	if (errno_str($return) == "ENOMEM")
		WriteTest("snapshot_read_next(): failed, out of memory on get_image_page(GFP_ATOMIC, PG_ANY).\n")
	else if ($return < 0) {
		s = sprintf("snapshot_read_next(): failed, unknown reason: %d.\n", $return)
		WriteTest(s)
	}
}

probe kernel.function("save_image@kernel/power/swap.c") {
	trace_in("")
}

probe kernel.function("save_image@kernel/power/swap.c").return {
	trace_out($$return)
}

probe kernel.function("save_image_lzo@kernel/power/swap.c") {
	trace_in("")
}

probe kernel.function("save_image_lzo@kernel/power/swap.c").return {
	trace_out($$return)
}

function do_required_swap_pages:long(nr_pages:long, flags:long) %{
	unsigned int nr_pages = (unsigned int)THIS->nr_pages;
	unsigned int flags = (unsigned int)THIS->flags;
	unsigned int required;

	required = PAGES_FOR_IO + ((flags & SF_NOCOMPRESS_MODE) ?
                nr_pages : (nr_pages * LZO_CMP_PAGES) / LZO_UNC_PAGES + 1);

	THIS->__retvalue = required;
%}

probe kernel.function("count_swap_pages@mm/swapfile.c") {
	trace_in("")
}

/*
probe kernel.statement("count_swap_pages@mm/swapfile.c+9") {
	s = sprintf("Swap pages: %d, in use pages: %d\n",
		$sis->pages, $sis->inuse_pages)
	WriteInfo(s)
}
*/

probe kernel.function("count_swap_pages@mm/swapfile.c").return {
	trace_out($$return)
	free_swap = $return

	required_swap = do_required_swap_pages(saved_nr_pages, saved_flags)

	if (required_swap > free_swap)
		s = sprintf("enough_swap(): Not enough free swap, required %d pages, only got %d free.\n",
			required_swap, free_swap)
	else
		s = sprintf("Got enough swap: hibernate requires %d pages, got %d free.\n",
			required_swap, free_swap)
	WriteTest(s)
}

probe kernel.statement("enough_swap@kernel/power/swap.c") {
	trace_in("")
	saved_nr_pages = $nr_pages	/* save it for when we enter count_swap_pages() */
	saved_flags = $flags		/* ditto */
}

/* inlined, so ignore
probe kernel.function("enough_swap@kernel/power/swap.c").return {
	trace_out($$return)
}
*/

/* ----- REMOVE BELOW? ------- */


probe kernel.function("suspend_valid_only_mem@kernel/power/suspend.c"),
      kernel.function("suspend_prepare@kernel/power/suspend.c"),
      kernel.function("suspend_enter@kernel/power/suspend.c"),
      kernel.function("suspend_devices_and_enter@kernel/power/suspend.c"),
      kernel.function("suspend_finish@kernel/power/suspend.c"),
      kernel.function("enter_state@kernel/power/suspend.c"),
      kernel.function("pm_suspend@kernel/power/suspend.c")
{
	trace_in("")
}

probe kernel.function("disable_nonboot_cpus@kernel/cpu.c") {
	trace_in("")
}

probe kernel.function("disable_nonboot_cpus@kernel/cpu.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("disable_nonboot_cpus(): CPU(s) could not be disabled.\n")
		WriteTest(s)
	}
}

%( kernel_v > "2.6.38" %?
probe kernel.function("syscore_suspend@drivers/base/syscore.c") {
	trace_in("")
}

probe kernel.function("syscore_suspend@drivers/base/syscore.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("syscore_suspend(): could not suspend all the system core.\n")
		WriteTest(s)
	}
}
%)

probe kernel.function("suspend_valid_only_mem@kernel/power/suspend.c").return {
	trace_out($$return)
}

probe kernel.function("suspend_enter@kernel/power/suspend.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("suspend_enter(): failed to enter the desired system sleep state.\n")
		WriteTest(s)
	}
}

probe kernel.function("suspend_devices_and_enter@kernel/power/suspend.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("suspend_devices_and_enter(): failed to suspend devices and enter the desired system sleep state.\n")
		WriteTest(s)
	}
}

/* inlined so cannot trace
probe kernel.function("suspend_finish@kernel/power/suspend.c").return {
	trace_out($$return)
}
*/

probe kernel.function("enter_state@kernel/power/suspend.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENODEV") {
		s = sprintf("enter_state(): failed because valid_state() returned -ENODEV. There probably isn't support for entering the specific S state.\n")
		WriteTest(s)
	} else if (errno_str($return) == "EBUSY") {
		s = sprintf("enter_state(): failed because it could not get hold of the pm_mutex.\n")
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("enter_state(): failed because either suspend_prepare() or suspend_devices_and_enter() failed.\n")
		WriteTest(s)
	}
}

probe kernel.function("pm_suspend@kernel/power/suspend.c").return {
	trace_out($$return)
	if (errno_str($return) == "EINVAL") {
		s = sprintf("pm_suspend(): failed because the state argument was wrong, was %d should be > PM_SUSPEND_ON and < PM_SUSPEND_MAX.\n", $state)
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("pm_suspend(): failed because enter_state() failed.\n")
		WriteTest(s)
	}
}

/*
 *  kernel/power/suspend_test.c tests
 *  	used for suspend testing, so trace enter/exit points but
 *	don't care about failure returns
 */
probe kernel.function("*@kernel/power/suspend_test.c") {
	trace_in("")
}

probe kernel.function("*@kernel/power/suspend_test.c").return {
	trace_out($$return)
}

/* ---------------------------------------------------- */

/*
 *   drivers/acpi/nvs tests
 */
/* TODO KEEP */
probe kernel.function("*@drivers/acpi/nvs.c") {
	trace_in("")
}

/* TODO KEEP */
probe kernel.function("suspend_nvs_register@drivers/acpi/nvs.c").return,
      kernel.function("suspend_nvs_alloc@drivers/acpi/nvs.c").return,
      kernel.function("suspend_nvs_save@drivers/acpi/nvs.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOMEM") {
		s = sprintf("%s could not register a NVS region.\n", probefunc())
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("%s failed for some unknown reason.\n", probefunc())
		WriteTest(s)
	}
}

/* TODO KEEP */
probe kernel.function("suspend_nvs_free@drivers/acpi/nvs.c").return,
      kernel.function("suspend_nvs_restore@drivers/acpi/nvs.c").return {
	trace_out($$return)
}


/* ---------------------------------------------------- */

/*
 *  kernel/power/process.c tests
 */
probe kernel.function("*@kernel/power/process.c")
{
	trace_in("")
}

probe kernel.function("thaw_tasks@kernel/power/process.c").return,
      kernel.function("thaw_processes@kernel/power/process.c").return {
	trace_out($$return)
}

/* ---------------------------------------------------- */

probe kernel.function("*@kernel/power/user.c") {
	trace_in("")
}

probe kernel.function("*@kernel/power/user.c").return {
	trace_out($$return)
}

/* ---------------------------------------------------- */

probe kernel.function("freeze_task@kernel/freezer.c") {
	s = sprintf("freeze task %d \"%s\"\n",
		$p->pid, kernel_string($p->comm))
	WriteTaskDebug(s)
	tasks_frozen[$p->pid] = 1
	tasks_frozen_names[$p->pid] = kernel_string($p->comm)
}

/*
probe kernel.function("__thaw_process@kernel/freezer.c") {
	//s = sprintf("thaw task %d \"%s\"\n", $p->pid, kernel_string($p->comm))
	//WriteInfo(s)
}
*/

/* ---------------------------------------------------- */

/*
 * Interesting funcs in drivers/acpi/sleep
 */
probe kernel.function("acpi_sleep_tts_switch@drivers/acpi/sleep.c"),
      kernel.function("tts_notify_reboot@drivers/acpi/sleep.c"),
      kernel.function("acpi_sleep_prepare@drivers/acpi/sleep.c"),  /* KEEP */
      kernel.function("acpi_pm_prepare@drivers/acpi/sleep.c"),	   /* KEEP */
      kernel.function("acpi_pm_finish@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_end@drivers/acpi/sleep.c"),
      kernel.function("acpi_suspend_begin@drivers/acpi/sleep.c"),
      kernel.function("acpi_suspend_enter@drivers/acpi/sleep.c"),
      kernel.function("acpi_suspend_begin_old@drivers/acpi/sleep.c"),
      kernel.function("acpi_pm_thaw@drivers/acpi/sleep.c"),
      kernel.function("acpi_suspend@drivers/acpi/sleep.c"),
      kernel.function("acpi_power_off_prepare@drivers/acpi/sleep.c"),
      kernel.function("acpi_power_off@drivers/acpi/sleep.c")
{
	trace_in("")
}

/* Following are in-lined, so cannot be traced :-(
 *
 *    "acpi_nvs_nosave@drivers/acpi/sleep.c"
 *    "__acpi_pm_prepare@drivers/acpi/sleep.c")
 */

/* TODO: KEEP */
probe kernel.function("acpi_sleep_prepare@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("acpi_sleep_prepare(): failed - this can only occur because the\nacpi_wakeup_address was not set. Without this, resume cannot work because it needs some\ncontext to resume from.\n")
		WriteTest(s)
	}
}

probe kernel.function("acpi_pm_prepare@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("acpi_pm_pre_suspend(: failed probably because suspend_nvs_save() fails.\nThe system could not save to the ACPI NVSregion, normally because of a iomapping\nfailure (out of memory).\n")
		WriteTest(s)
	}
}

probe kernel.function("acpi_suspend_begin@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "ENOSYS") {
		s = sprintf("acpi_suspend_begin() failed - ACPI does not support state %d.\n", $pm_state)
		WriteTest(s)
	} else if (errno_str($return) == "ENOMEM") {
		s = sprintf("acpi_suspend_begin() failed - because suspend_nvs_alloc() could not\nallocate a NVS region.\n")
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("acpi_suspend_begin() failed for some unknown reason.\n")
		WriteTest(s)
	}
}

probe kernel.function("acpi_suspend_enter@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "EINVAL") {
		s = sprintf("acpi_suspend_enter(): failed because acpi_suspend_lowlevel() detected a\nwakeup header that did not match the correct wakeup header signature.\n")
		WriteTest(s)
	} else if (errno_str($return) == "EFAULT") {
		s = sprintf("acpi_suspend_enter(): failed because acpi_enter_sleep_state() count not\nenter into the chosen sleep state. This is could be a H/W issue on the southbridge.\n")
		WriteTest(s)
	} else if ($return != 0) {
		s = sprintf("acpi_suspend_enter(): failed for some unknown reason.\n")
		WriteTest(s)
	}
}

/*
skip
probe kernel.function("acpi_suspend_state_valid@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if ($return == 0) {
		s = sprintf("acpi_suspend_enter(): function was passed a bad PM state: %d\n", $pm_state)
		WriteTest(s)
	}
}
*/

probe kernel.function("acpi_suspend_begin_old@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if ($return !=0) {
		s = sprintf("acpi_suspend_begin_old(): failed because acpi_suspend_begin() or __acpi_pm_prepare() failed.")
		WriteTest(s)
	}
}

probe kernel.function("acpi_suspend@drivers/acpi/sleep.c").return {
	trace_out($$return)
	if (errno_str($return) == "EINVAL") {
		s = sprintf("acpi_suspend(): failed because it was given an invalid ACPI state: %d.\n", $acpi_state)
		WriteTest(s)
	} else if ($return !=0) {
		s = sprintf("acpi_suspend(): failed because pm_suspend() failed.")
		WriteTest(s)
	}
}

probe kernel.function("acpi_sleep_tts_switch@drivers/acpi/sleep.c").return,
      kernel.function("tts_notify_reboot@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_finish@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_end@drivers/acpi/sleep.c").return,
      kernel.function("acpi_pm_thaw@drivers/acpi/sleep.c").return,
      kernel.function("acpi_power_off_prepare@drivers/acpi/sleep.c").return,
      kernel.function("acpi_power_off@drivers/acpi/sleep.c").return
{
	trace_out($$return)
}

/* ---------------------------------------------------- */

/*
 *  drivers/acpi/wakeup.c
 *	nothing special to debug
 */
probe kernel.function("*@drivers/acpi/wakeup.c") {
	trace_in("")
}

probe kernel.function("*@drivers/acpi/wakeup.c").return {
	trace_out($$return)
}

/* ---------------------------------------------------- */

/*
 *  drivers/acpi/acpica/hwsleep.c
 *	TODO - check all ACPI return states :-(
 */
probe kernel.function("*@drivers/acpi/acpica/hwsleep.c") {
	trace_in("")
}

/*
TODO: These cause breakage  - can we select the appropriate funcs that don't
probe kernel.function("*@drivers/acpi/acpica/hwsleep.c").return {
	trace_out($$return)
}
*/

/*
 *  suspend_console@kernel/printk.c
 *	just to see when we suspend/resume the consoles
 */
probe kernel.function("suspend_console@kernel/printk.c"),
      kernel.function("resume_console@kernel/printk.c") {
	trace_in("")
}

probe kernel.function("suspend_console@kernel/printk.c").return,
      kernel.function("resume_console@kernel/printk.c").return {
	trace_out($$return)
}

/* ---------------------------------------------------- */


/* KEEP, TODO FIX the $state struct problem */
probe kernel.function("device_suspend_noirq@drivers/base/power/main.c") {
	trace_in("")
	/*
	ops = pm_noirq_op_ops($dev)
	state = $state
	addr = pm_noirq_op_func(ops, state)
	store_hash_long(addr)
	*/
}

/* KEEP */
probe kernel.function("device_suspend_noirq@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("device_suspend_noirq(): failed to change a power state on device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}

probe kernel.function("device_resume_noirq@drivers/base/power/main.c"),
      kernel.function("pm_noirq_op@drivers/base/power/main.c"),   /* KEEP */
      kernel.function("legacy_resume@drivers/base/power/main.c"),
      kernel.function("async_resume@drivers/base/power/main.c"),
      kernel.function("device_complete@drivers/base/power/main.c"),
      kernel.function("async_suspend@drivers/base/power/main.c"),
      kernel.function("dpm_resume_noirq@drivers/base/power/main.c"),
      kernel.function("dpm_resume@drivers/base/power/main.c"),
      kernel.function("dpm_resume_end@drivers/base/power/main.c"),
      kernel.function("dpm_complete@drivers/base/power/main.c"),/* */
      kernel.function("dpm_suspend_noirq@drivers/base/power/main.c"),  /* KEEP */
      kernel.function("dpm_suspend_start@drivers/base/power/main.c"),
      kernel.function("device_pm_wait_for_dev@drivers/base/power/main.c") {
	trace_in("")
}


probe kernel.function("dpm_resume_noirq@drivers/base/power/main.c").return,
      kernel.function("async_resume@drivers/base/power/main.c").return,
      kernel.function("dpm_resume@drivers/base/power/main.c").return,
      kernel.function("legacy_suspend@drivers/base/power/main.c").return,
      kernel.function("device_complete@drivers/base/power/main.c").return,
%( kernel_v > "2.6.38" %?
      /* inlined, on some versions, this is a hack */
      kernel.function("dpm_complete@drivers/base/power/main.c").return,
%)
      kernel.function("dpm_resume_end@drivers/base/power/main.c").return,
      kernel.function("device_pm_wait_for_dev@drivers/base/power/main.c").return {
	trace_out($$return)
}

probe kernel.function("device_prepare@drivers/base/power/main.c"),
      kernel.function("legacy_suspend@drivers/base/power/main.c") {
	trace_in(s)
	s = sprintf("dev: %s (%s)\n", device_name($dev), device_driver_name($dev))
	WriteDeviceDebug(s)
}

probe kernel.function("async_suspend@drivers/base/power/main.c") {
	trace_in(s)
	s = sprintf("dev: %s (%s)\n", device_name($data), device_driver_name($data))
	WriteDeviceDebug(s)
}

probe kernel.function("async_suspend@drivers/base/power/main.c").return {
	trace_out($$return)
}

/* KEEP */
probe kernel.function("pm_noirq_op@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("pm_noirq_op(): failed to change a power state on device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}

probe kernel.function("device_resume_noirq@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("device_resume_noirq(): failed to change a power state on device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}


/* KEEP */
probe kernel.function("dpm_suspend_noirq@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("dpm_suspend_noirq(): failed change a power state on a device.\n")
		WriteTest(s)
	}
}

probe kernel.function("legacy_suspend@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("legacy_suspend(): failed to change a power state on device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}


probe kernel.function("device_prepare@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("device_prepare(): failed to prepare a device for a system power transition: device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}

probe kernel.function("legacy_resume@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("legacy_resume(): failed to resume device %s (%s).\n", device_name($dev), device_driver_name($dev))
		WriteTest(s)
	}
}

probe kernel.function("device_resume@drivers/base/power/main.c") {
	s = sprintf("resuming device %s (%s)\n",
		device_name($dev), device_driver_name($dev))
	WriteDeviceDebug(s)
	h = hash_dev_func($dev, 0)
	store_hash_long(h)
	saved_device_name = device_name($dev)
	saved_device_driver_name = device_driver_name($dev)

}

probe kernel.function("device_resume@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return == 0) {
		devices_resumed[device_name($dev)] = 1;
	} else {
		devices_resumed[device_name($dev)] = 0;
		s = sprintf("device_resume(): failed to resumed device %s (%s): %s\n",
			device_name($dev), device_driver_name($dev), $$return)
		WriteTest(s)
	}
}

probe kernel.function("dpm_resume@drivers/base/power/main.c").return {
	trace_out($$return)

	dev_ok = 0
	dev_fail = 0

	foreach (dev in devices_resumed) {
		if (devices_resumed[dev] == 1)
			dev_ok++
		else
			dev_fail++
	}

	if (dev_fail == 0)
		s = sprintf("%d devices resumed correctly.\n", dev_ok)
	else
		s = sprintf("%d of %d devices failed to resume.\n", dev_fail, dev_ok)
	WriteTest(s)

	if (dev_fail > 0) {
		devs = ""
		foreach (dev in devices_resumed)
			if (devices_resumed[dev] == 0)
				devs = " " . dev

		s = sprintf("Devices that failed to resume: %s.\n", devs)
		WriteInfo(s)
	}

	foreach (dev in devices_resumed) {
		if (!(dev in devices_suspended)) {
			s = sprintf("dpm_resume(): device %s was suspended but not resumed for some reason.\n", dev)
			WriteTest(s)
		}
	}
}

probe kernel.function("dpm_suspend_start@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("dpm_suspend_start(): dpm_prepare() or dom_suspend() failed, cannot prepare devices for PM transistion and suspend.\n")
		WriteTest(s)
	}
}

probe kernel.function("dpm_prepare@drivers/base/power/main.c").return {
	trace_out($$return)
	if ($return != 0) {
		s = sprintf("dpm_prepare(): failed to prepare a device for a power transision. See kernel log for more info on the device.\n")
		WriteTest(s)
	}
}

probe kernel.function("device_suspend@drivers/base/power/main.c") {
	s = sprintf("suspending dev: %s (%s)\n",
		device_name($dev), device_driver_name($dev))
	WriteDeviceDebug(s)
	saved_device_name = device_name($dev)
	saved_device_driver_name = device_driver_name($dev)
}

probe kernel.function("__device_suspend@drivers/base/power/main.c").return {
	if ($return == 0) {
		devices_suspended[device_name($dev)] = 1;
	} else {
		devices_suspended[device_name($dev)] = 0;
		s = sprintf("__device_suspend(): device %s (%s) failed to suspend.\n",
			saved_device_name, saved_device_driver_name)
		WriteTest(s)
	}
}

%( kernel_v > "2.6.38" %?
probe kernel.function("acpi_suspend_lowlevel@arch/x86/kernel/acpi/sleep.c") {
	trace_in("")
	s = sprintf("Jumping to do_suspend_lowlevel to save processor state.\n")
	WriteInfo(s)
}

probe kernel.function("acpi_suspend_lowlevel@arch/x86/kernel/acpi/sleep.c").return {
	trace_out($$return)
	s = sprintf("Returning from suspend.\n")
	WriteInfo(s)
	s = sprintf("Resumed. Assuming BIOS -> kernel transsition works correctly.\n")
	WriteTest(s)
}
%)

probe kernel.function("acpi_enter_sleep_state@drivers/acpi/acpica/hwsleep.c") {
	trace_in("")
	s = sprintf("Going into sleep state %d.\n", $sleep_state)
	WriteInfo(s)
}

probe kernel.function("acpi_hw_write_pm1_control@drivers/acpi/acpica/hwregs.c") {
	trace_in("")
	s = sprintf("pm1a_control = %x, pm1b_control = %x\n",
		$pm1a_control, $pm1b_control)
	WriteDebug(s)
}
